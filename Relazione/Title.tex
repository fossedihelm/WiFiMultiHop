\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
\usepackage[utf8]{inputenc}
\usepackage{epstopdf}
\usepackage{float}
\usepackage{courier}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[export]{adjustbox}
\usepackage{graphicx}
\usepackage{hyperref}



%
\newcommand{\exedout}{%
	\rule{0.8\textwidth}{0.5\textwidth}%
}

\begin{document}
	\mainmatter              % start of the contributions
	%
	\title{WiFi Direct Multi-Group Hopping}
	%
	\author{Federico Fossemò, Gianluca Guidi}
	%
	\institute{Università di Bologna, Dipartimento di Scienze dell'Informazione
		\email{federico.fossemo@studio.unibo.it, gianluca.guidi3@studio.unibo.it}}
	\maketitle
	
	\begin{abstract}
	\end{abstract}
	%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduzione}
%	\begin{itemize}
%		\item 
%	\end{itemize}

\paragraph{} Questo lavoro, inserito nel contesto del corso di Sistemi Mobili, consiste nello studio di alcune potenzialità di WiFi Direct.\\
WiFi Direct consente la formazione di gruppi di comunicazione peer-to-peer. Ogni gruppo è formato da un GO (Group Owner), che agisce come access point, e più client connessi al GO. I gruppi sono indipendenti e lo standard non prevede una procedura per connettere più gruppi tra loro, per formare dei cluster più ampi.

\paragraph{} Un possibile modo per collegare più gruppi consiste nell'avere un client che si connette a più GO, rimanendo connesso a ciascuno di essi per un determinato perdiodo di tempo. Il client, saltando da un GO all'altro ed inoltrando i messaggi ricevuti, è in grado di agire da ponte tra i gruppi, permettendo lo scambio di messaggi tra dispositivi appartenenti a gruppi diversi.

\paragraph{} Lo scopo del progetto presentato è quello di fornire un proof-of-concept del metodo appena descritto, analizzare i ritardi introdotti ed eventualmente trovare un adeguato tempo di permanenza nel gruppo. L'implementazione consiste in un'applicazione Android che fa uso del framework WifiP2p fornito dalla piattaforma. Lo scenario analizzato è quello in cui sono presenti due Group Owner ed un client che si connette in alternanza ad essi.

%	\begin{enumerate}
%		\item \textit{}
%	\end{enumerate}
	
	

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scenario del test}

\paragraph{} I dispositivi Android a disposizione per questo progetto sono 3: essi sono sufficienti per creare le condizioni minime per poter testare l'idea del salto tra gruppi: due dispositivi agiscono come Group Owner, mentre il terzo agirà come client che si connette in alternanza tra i primi due, rimanendo connesso a ciascuno di essi per un periodo di tempo prefissato.

\paragraph{} Ai due Group Owner sono stati assegnati due ruoli. Il primo, detto generator, genera periodicamente messaggi da inoltrare. Il secondo, detto replier, non fa altro che rispedire al mittente i messaggi ricevuti. Il generator prende nota dei tempi di invio e di ricezione, in modo da poter calcolare l'RTT (round trip time) presente tra sè stesso ed il replier. La stima di questo RTT è influenzata dai tempi di processamento e dal tempo di trasmissione dei messaggi. Tuttavia il tempo di processamento dovrebbe essere molto più basso rispetto ad i tempi di ritardo e trasmissione, mentre la piccola dimensione dei messaggi fa sì che la misurazione finale non venga distorta in maniera significativa.
%	\cite{relatedWork}

%	\ref{leo_arch}

%	\begin{figure}[H]
%		\includegraphics[scale=0.3,center]{img/}
%		\caption{}
%		\label{label}
%	\end{figure}
%	\noindent

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		 
\section{Architettura}

\paragraph{} In questa sezione verrà descritta a grandi linee l'implementazione dell'applicazione usata per i test. Il protocollo da noi previsto prevede diversi tipi di messaggi che possono essere inviati. Quando il client 
riesce a stabilire una nuova connessione, esso invia un messaggio di tipo REGISTER che contiene la lista dei GO raggiungibili dal client. La ricezione di questo messaggio anticipa lo scambio di messaggi di tipo DATA, il cui scopo
è solamente quello di trasmettere dati per la rilevazione delle statistiche. Quando il timer impostato dall'utente scade, il client avvia una procedura di disconnessione che consiste nell'invio di un messaggio di STOP e nella ricezione 
di un relativo STOP\_ACK. A questo punto il client è in grado di avviare la disconnessione a livello data link con la certezza di non aver perso informazioni a livello applicativo.
Le classi principali sono MainActivity, DeviceManager, Peer e MessageManager.

\paragraph{MainActivity} è un'activity che gestisce l'interfaccia grafica. L'aspetto dell'interfaccia cambia grazie all'uso dei fragment.
//TODO Fosse lascio a te la parte in cui descriviamo l'interfaccia grafica.

\paragraph{DeviceManager} è un thread che si occupa di gestire la rete a livello di WiFi Direct. Implementa varie callback che vengono chiamate quando si verificano determinati eventi.
Ad esempio \emph{onConnectionInfoAvailable()} viene chiamata quando alcune informazioni sulla connessione sono disponibili: questo significa che la connessione è stata stabilita.
\emph{DeviceManager} si occupa anche di istanziare una delle due sottoclassi di Peer (\emph{GroupOwner} e \emph{Client}) a seconda del ruolo che il dispositivo deve svolgere. Questi oggetti vengono informati sui cambiamenti della connessione, in particolare su quando essa viene stabilita.

\paragraph{Peer} è una classe astratta che rappresenta un peer, sia esso GO o client. Il suo compito è quello di rispondere al completato stabilimento di una nuova connessione (\emph{onConnect()}), 
di gestire i messaggi ricevuti (\emph{receiveMessage()}) e di gestire la procedura di disconnessione (\emph{initiateDisconnection()} e \emph{onDisconnect()}). 
\emph{Peer} genera anche un'istanza di una sottoclasse di \emph{MessageManager} (\emph{GroupOwnerMessageManager} o \emph{ClientMessageManager}).

\paragraph{MessageManager} è un thread che gestisce la ricezione e l'invio dei messaggi. L'invio dei messaggi è inoltrato ad un thread \emph{Sender} generato appositamente dal \emph{MessageManager}. Il motivo dell'esistenza di due thread, per ricezione ed invio di messaggi, risiede nella possibilità di eseguire le due operazioni contemporaneamente senza bloccarsi, in particolare per non rischiare di perdere informazioni in arrivo. Il \emph{Sender} mantiene 
una coda di messaggi da inviare. La procedura di disconnessione prevede l'invio di un messaggio (STOP per il client e STOP\_ACK per il GO); questo messaggio deve essere l'ultimo inviato, perciò è anche previsto un meccanismo che 
permette al thread di aspettare fino a quando la coda dei messaggi da inviare non sia vuota.

\paragraph{GroupOwner} una sottoclasse di \emph{Peer} che rappresenta un Group Owner. Il GO può assumere il ruolo di generator o di replier; questo ruolo può essere cambiato anche dopo la creazione. Se il ruolo è quello di generator, 
dopo aver ricevuto il messaggio REGISTER dal client, verrà avviata la generazione dei messaggi all'interno del \emph{GroupOwnerMessageManager}. La raccolta delle statistiche viene effettuata dal generator all'invio e alla ricezione dei messaggi.

\paragraph{GroupOwnerMessageManager} è una sottoclasse di \emph{MessageManager} che si occupa dell'invio e della ricezione dei messaggi da parte del GroupOwner. Questa classe viene istanziata solo una volta nel momento in cui 
il dispositivo diventa un GO: viene creato un ServerSocket, poi ad ogni connessione viene creato un socket associato al client. Se il GO è un generatore, quando viene stabilita un connessione il\emph{GourpOwnerMessageManager} lancia 
un thread \emph{MessageGenerator} che non fa altro che generare nuovi messaggi ed inviarli con una frequenza prefissata (100 ms). Quando viene effettuata la disconnessione il \emph{MessageGenerator} viene terminato.

\paragraph{Client} una sottoclasse di \emph{Peer} che rappresenta un client. Quando è stata stabilita una nuova connessione a livello di WiFi Directi il client lancia un'istanza di \emph{ClientMessageManager}, la quale dà inizio allo 
scambrio di messaggi. Viene mantenuta una coda per ogni GO, 
in cui il client memorizza i messaggi ricevuti. Le code sono indicizzate in base al MAC address della destinazione. Quando il client si connette ad un GO la cui coda non è vuota, esso invia immediatamente tutti i messaggi al GO al 
fine di svuotare la coda. Quando il tempo allocato alla connessione scade, il client dà inizio alla procedura di disconnessione inviando un messaggio STOP. Al momento della ricezione del messaggio STOP\_ACK il client avvia 
la disconnessione a livello di WiFi Direct. Il client prende nota del tempo di riconnessione, ovvero il tempo che intercorre tra l'inizio della disconnessione da un GO all'avvenuta connessione con un altro GO. La misura ottenuta non 
tiene conto del tempo necessario a stabilire una connessione TCP.

\paragraph{ClientMessageManager} è una sottoclasse di \emph{MessageManager} il cui scopo è gestire l'invio e la ricezione dei messaggi da parte del Client. Questo thread viene rilanciato ogni volta che viene stabilita una nuova 
connessione e viene terminato al termine della connessione. Questa scelta è dettata dal fatto che il socket è associato ad una connessione, quindi è più semplice gestirlo in questo modo. È stato utilizzato un thread pool per minimizzare 
il tempo di creazione del thread. Il client dà inizio allo scambio di messaggi inviando un messaggio REGISTER contenente la lista di GO nelle vicinanze. Vengono gestiti l'invio e la ricezione dei messaggi come descritti in 
\emph{MessageManager} e \emph{Client}.
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Section4} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%			
\section{Section5}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%			
\section{Section6}

	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%			
\section{Section7}

	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%			
\section{Section8}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{}
%	\bibitem{}
\end{thebibliography}

\end{document}